
## 自动化部署

[TOC]

---
#### 关键名词

`devops` `jenkins` `harbor` `gitflow` `docker`

#### 原部署流程

```
本地代码编译打包；
ftp上传至开发环境服务器，文件夹包含Dockerfile、jar、前端静态文件；
执行命令，创建docker镜像；
运行docker镜像；

自测没有问题进行提测，测试人员ftp上传jar包至测试环境指定文件夹，文件夹包含Dockerfile、jar、前端静态文件；
执行命令，创建docker镜像；
运行docker镜像；

测试环境没有问题部署beta环境，运维人员ftp上传jar包至beta环境指定文件夹，文件夹包含Dockerfile、jar、前端静态文件；
执行命令，创建docker镜像；
运行docker镜像；

beta环境没有问题部署正式环境，运维人员ftp上传jar包至正式环境指定文件夹，文件夹包含Dockerfile、jar、前端静态文件；
执行命令，创建docker镜像；
运行docker镜像；

```

**优势**
```
适用于频繁更改的、部署环境较少的，可直观检测整个流程。
```
**劣势**
```
太多的重复工作（特别是多个环境及hotfix处理）。
```

#### 现部署流程

```
个人分支开发功能，自测代码无误则合并多人协作分支（dev）（开发环境）；
开发环境功能正常，dev合并至release（测试环境）；
测试环境功能正常，release合并至beta（beta环境）；
beta环境功能正常，beta合并至master（正式环境）。
```
**优势**
```
适用于敏捷团队，满足频繁迭代的需要。
开发人员只需要注重于功能开发，开发提测部署都能通过git工作流来规范且记录版本。
在多环境部署情况下，一劳永逸，只要环境搭建完成部署仅仅就是合并分支。
在需要热修复的情况下，更快的更新到各个环境。
```
**劣势**
```
并没有完全自动化，需要检查错误信息，需要检查docker运行情况。
```

我们能节省的

![](index_files/c6b3aac9-b749-4c81-9ae4-0423eb4702f2.jpg)


#### git工作流
![](index_files/93f38bfe-3546-4653-a9ab-544247ad34e3.jpg)

**说明**

```
每个分支（master、release、beta）具体对应什么环境由项目组成员来确定，这就是一个定义而已。

master： 正式环境。
beta: beta环境，验证后代码合并master。
hotfix： 热修复分支，用于beta环境及线上环境缺陷修复的临时分支，修复完成后，应该马上合并至各个分支并删除该热修复分支。
feature： 功能开发分支。
dev: 多人协作分支。
release： 测试环境，当dev分支的功能需要进行提测，合并dev至release；当测试环境需要修复bug，在release切换个人bugfix分支，完成修复后合并release及dev分支。

```

**打版本方式**

- git tag

```
git tag -l -n
git tag -a v1.0 -m 'version 1.0'
git tag -d v1.0
git push origin v1.0
```

- gogs操作

![](index_files/fa51e636-5090-4944-bb93-97238e70bdba.png)

**注意**


    不能直接在release、beta、master等分支直接更改。

#### 流程图展示
![](index_files/79ee49c7-e2ff-43c9-ac56-40dad52ff623.png)

#### 准备环境

**打包环境**

```
jdk
maven
nodejs
webpack
jenkins
能访问gogs
能上传镜像至harbor
```

**服务机器**

```
原部署应有的环境
能访问harbor
docker开启远程访问 （http://blog.csdn.net/wangtaoking1/article/details/44494847）
```

**相关地址**
```
**jenkins** 
http://192.168.1.163:8008/

**maven私服**
http://192.168.1.73:8081/

**docker镜像仓库**
https://192.168.1.207/
```

#### jenkinsfile

![](index_files/f3dd0486-d37f-4687-838d-c8c2ff3ae80e.png)

```
def devHost = '192.168.1.149'
def project = 'pps'
def devDockerDaemon = "tcp://${devHost}:2375"
def serverName = 'bg-finder'
def registryUrl = '192.168.1.207'

    pipeline {
        agent any
            stages {
                stage('代码更新') {
                    steps {
                        dir('front') {
                            git branch: 'release', url: 'http://192.168.1.122:3000/SKB_PPS/bg-finder-fe.git'
                        }
                        dir('server') {
                            git branch: 'release',url: 'http://192.168.1.122:3000/SKB_PPS/bg-finder.git'
                        }
                    }
                }
                stage('打包前端') {
                    steps {
                        sh """
                            #!/bin/bash -ilex
                            cd ./front
                            rm -rf node_modules/
                            mkdir -p dist/dev/
                            cnpm install
                            cnpm run build

                        """
                    }
                }
                stage('打包后端') {
                    steps {
                        sh """
                            cd ./server
                            mvn clean compile
                            mvn package
                        """
                    }
                }
                stage('创建镜像') {
                    steps {
                        sh """
                            mv -f ./server/target/*.jar ./server/target/${serverName}.jar
                            mv -f ./front/dist/dev/*.tar.gz ./server/target/${serverName}.tar.gz
                            cp ./server/Dockerfile ./server/target/
                            docker build -t ${registryUrl}/${project}/${serverName}:$BUILD_NUMBER ./server/target/.
                            rm -rf ./server/target/
                        """
                    }
                }
                stage('推送镜像到仓库') {
                    steps {
                        sh """
                            docker push ${registryUrl}/${project}/${serverName}:$BUILD_NUMBER
                            docker rmi ${registryUrl}/${project}/${serverName}:$BUILD_NUMBER
                        """
                    }
                }
                stage('部署Dev环境') {
                    steps {
                        sh """
                            docker -H ${devDockerDaemon} stop ${serverName} | true
                            docker -H ${devDockerDaemon} rm -f ${serverName} | true
                            docker -H ${devDockerDaemon} run -d --name ${serverName} -v /tmp/unzip/:/pps/projects/bg-finder/unzip/ -v /pps/projects/bg-finder-front/:/pps/projects/bg-finder-front/ -v /pps/projects/bg-finder/logs/:/logs/ --add-host=contacts.pps.banggood.cn:192.168.1.149 --net=host -p 8083:8083 -e "spring.profiles.active=dev" --privileged=true --restart=always  ${registryUrl}/${project}/${serverName}:$BUILD_NUMBER
                        """
                    }
                }
            }
        }

```


#### dockerfile

```
FROM 192.168.1.207/sellercube/java:8-jre
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
ADD bg-finder.jar app.jar
ADD bg-finder.tar.gz /pps/projects/bg-finder-front/
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]
```

#### 触发构建方式

![](index_files/867a1068-b9ea-403a-91c6-677f1c71958c.png)

**scm方式参数说明**

`定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。`

```
在 Schedule 中填写 0 * * * *。

第一个参数代表的是分钟 minute，取值 0~59；
第二个参数代表的是小时 hour，取值 0~23；
第三个参数代表的是天 day，取值 1~31；
第四个参数代表的是月 month，取值 1~12；
最后一个参数代表的是星期 week，取值 0~7，0 和 7 都是表示星期天。

H 2 * * * （每天2:00 必须build一次源码）
5 * * * * （每5分钟检查一次源码变化）
```

**web钩子**

1. 设置构建方式为触发远程方式
`JENKINS_URL/job/bg-finder/build?token=TOKEN_NAME`

2. 添加web钩子
![](index_files/8ae394f6-d82f-4d04-a154-aaf14b354e1a.png)

#### 注意事项

- 对于同一个DockerRegistry中，一个项目有两个部署环境如何构建

> 内网部署两套环境（开发环境及测试环境）且都使用自动化部署的情况下，需要注意推送镜像的镜像名要做区分。
> 保证同一库里面的docker镜像不会被覆盖。

- 执行过程报错排查

>本地构建代码正常但在构建环境上失败，请检查检查环境的maven库对应包版本是否一致、maven编译插件指定的jdk版本是否过低等，并确保该环境能访问到公司maven私服。
>部署环境失败，目标服务机器是否能够正常访问到DockerRegistry并成功拉取镜像。

- 多个子模块如何构建

> 项目中有多个子模块时，根目录pom文件将各个模块关联，保证在根目录下执行mvn install能对各个模块完成打包，降低实现复杂度。

- pom文件需要添加maven-compiler-plugin插件

> 指定maven编译期间源码的开发版本及编译版本，与构建环境保持一致。

- npm install 报错

> 脚本删除node_modules

#### 相关资料

http://192.168.1.172:38080/docs/jenkins-conf.html
http://blog.csdn.net/aixiaoyang168/article/details/72818804
https://jenkins.io/doc/pipeline/tour/hello-world/