# 设计模式 

面向对象设计原则

原则|描述
-|-
单一职责（Single Responsiblity Principle SRP）|思考清楚对象的职责，越简单越可靠，不要妄想干很多事，哪样将什么也干不好！职责应该尽量明确单一！
开闭原则（Open Closed Principle，OCP）|对扩展开放，对修改关闭。常说的非侵入式扩展就是不改变原代码扩展，修改应该尽量收敛，不然到处都有！很乱！
里氏代换原则（Liskov Substitution Principle，LSP）|对应`多态`特性，兼容父类的接口，一定要兼容子类
接口隔离原则（Interface Segregation Principle，ISP）|明确依赖的最小单位，不要依赖一个臃肿的东西，应该依赖比较细粒度的接口，需要反复权衡接口粒度问题！
依赖倒置原则（Dependency Inversion Principle，DIP）|1.高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口   2.抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。
*最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）*|一个对象对自己需要耦合关联调用的类应该知道的更少。这样会导致类之间的耦合度降低，每个类都尽量减少对其他类的依赖，因此，这也很容易使得系统的功能模块相互独立，之间不存在很强的依赖关系。
*合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）*|人与器官是**合成**，同生命周期，人与人群是**聚合**，每个人都是不同生命周期。在使用继承进行父类复用时，随着子类变多，父类复用性则越来越少，会带来以下缺点：第一，继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则；第二：如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。而用合成和聚合的时候新对象和已有对象的交互往往是通过**接口或者抽象类**进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。【使用继承或者是接口需权衡】



## 创建型模式

### 1.简单工厂

【一具体工厂产出一具体实现】一个抽象类下有多个实现，由一个具体工厂类(类名通常以`Factory`结尾)决定如何选择实现

### 2.抽象工厂

【一工厂产出多个具体，升级版】，和简单工厂相比，工厂类本身实现抽象，抽象工厂+多个具体工厂实现，将抽象工厂暴露给依赖方使用。

### 3.单例模式

[单例模式讲解](http://www.runoob.com/design-pattern/singleton-pattern.html)
根据`是否懒加载`，`是否线程安全`,分为`懒汉式`,`饿汉式`,有多种实现手段。
这种模式一般用于全局类（比如站点配置），只有一个实例的场景。

### 4.建造者模式

[讲解](http://blog.csdn.net/carson_ho/article/details/54910597)

>1. 电脑城老板（Diretor）和小成（Client）进行需求沟通（买来打游戏？学习？看片？）
2. 了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）
3. 指挥装机人员（ConcreteBuilder）去构建组件；
4. 将组件组装起来成小成需要的电脑（Product）


### 5.原型模式

实现可克隆（Cloneable）接口的类，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。

原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。

## 结构型模式

### 6.适配器模式

[适配器模式讲解](http://blog.csdn.net/carson_ho/article/details/54910430)

>背景：小成买了一个进口的电视机
冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容
解决方案：设置一个适配器将插头输出的220V转变成110V

创建一个适配器类（通常以`Adapter`结尾）继承一个待适配的类（通常以`Adaptee`以尾），并实现适配接口。

### 7.装饰器模式

[装饰器模式讲解](http://blog.csdn.net/coderjyf/article/details/56845987)
装饰者（通常以`Decorator`结尾）和被装饰对象实现共同的接口（Component），装饰者类中引用了被装饰对象，这样
装饰者的实现方法，就可以做一些装饰操作。

比如ES6加入了一个新特性，在类上加入@xxx可以装饰类。

### 8.代理模式

代理类（一般以`Proxy`结尾），典型的如WCF生成客户端代理进行远程调用，java中`RestTemplate`代理远程api的访问。
代理类实现了和被代理类一样的代理接口，这样客户端使用的时候可以通过代理类调用被代理类的方法，（透明访问）。

### 9.外观模式

也叫门面模式，面向对象三特性之一【封装】， 对外暴露一个门面对象，内部对象全部隐藏在背后，门面类通常以`Facade`结尾

### 10.桥接模式

桥的两边为两个`抽象桥头`，桥两边任意两个具体类通信，都需要通过抽象类通信，降低耦合。

### 11.组合模式

典型的无限级树结构就是，node嵌套node,自己包含自己。

### 12.享元模式

一般用hashmap实现对象的缓存，取对象的时候先去缓存里面找，通常用于创建对象成本非常高的场景。当然也有对象池可以做到（`Pool`）。

## 行为型模式

### 13.策略模式

多个具体策略类实现一个抽象的策略接口（通常以`Strategy`结尾），Context类封装对具体策略的使用（门面模式的思想）。

### 14.模板方法模式

用抽象类+override这种设计的就是这个模式，抽象类作为模板类（`Template`结尾或者`Abstract`开头的类）

### 15.观察者模式

发布订阅模式，比如C# event关键字。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
通常有多个具体观察者（以`Observer`结尾），订阅一个主题对象（通常以`Subject`结尾），主题对象里面引用了Observer抽象类，在自己状态变化时，通过Observer接口发布事件。

**现在多用EventBus来使用这个模式**

### 16.迭代子模式

集合类中实现`Iterator`,里面有next方法。

比如ES6中新增了 迭代器。

### 17.责任链模式

常见于以`Handler`结尾的类设计，比如servlet中的filter，通常将`Hander`形成一个链条,每个handler接受和自己有关的责任任务，如果不接受返回false，则调用方会迭代到链条的下一位。

### 18.命令模式

一个命令抽象类（以`Command`结尾），通常该类中有`run`,`execute`的命令方法。命令抽象类拥有多个具体命令类，具体命令类用一个具体命令接受方（通常以`Receiver`结尾）作为构造参数，在命令方法执行时，调用Receiver中的某些方法。

### 19.备忘录模式

[备忘录模式讲解](https://www.jianshu.com/p/ce5ef07dcb66)

备忘录模式所涉及的角色有三个：备忘录（`Memento`），发起人（`Originator`），负责人（`Caretaker`）

1. 备忘录实现一个空接口（也叫窄接口），同时实现了统一访问和避免外部访问内部数据。【**白箱实现**】
2. 发起人可以`创建`备忘录，`保存`和`恢复`自己的状态，将自身的状态写入到备忘录对象中。
3. 负责人只能`保存`和`取回`备忘录（依赖那个空接口），因为是空接口，并不能修改备忘录。

> 1. 无忌（发起人）把乾坤大挪移（备忘录）交给了小昭（负责人）
2. 小昭保管起来（藏到身上，或者哈希表），小昭不懂武功看不懂（因为是用空接口屏蔽了备忘录的操作接口）
3. 哪天无忌又向小昭要回乾坤大挪移（向负责人取回备忘录），继续从上一次练功的地方开始练（发起人从备忘录中恢复状态）

### 20.状态模式

[状态模式讲解](http://www.runoob.com/design-pattern/state-pattern.html)
[电梯状态模式使用](http://blog.csdn.net/hguisu/article/details/7557252)
[金库警报系统状态模式](https://www.jianshu.com/p/378ed95e7f0d)

*现在我们推荐使用（FSM）有穷状态自动机，比如：Spring Statemachine*

可以用于消除 if...else，switch...case 等条件选择语句。

1. 动作（一些方法，比如按录音键）  
2. 状态（播放、暂停、录音状态）   
3. 行为（开始播放，开始录音，暂停）

>1. 将状态有关的动作聚合到一个抽象状态接口
2. 按照不同的状态，实现多个具体状态类（依赖Context）
3. 具体状态类中的动作执行时，通过Context参数调用行为方法

### 21.访问者模式

[访问者模式](http://www.runoob.com/design-pattern/visitor-pattern.html)

参与角色：1.访问者（`Visitor`，里面有个`visit`方法），被访问者（里面有个`accept`方法）

>1. 记者（Visitor）需要采访学生、老师、工人、农民（被访问者），问：你幸福吗？访问者类中有多个采访对象的【重载】
2. 被访问者接受（accept）时，调用采访者（作为参数传入）的访问方法（visit）



### 22.中介者模式(Mediator)

生活中无处不中介！

>1. 通过媒人介绍男女朋友
2. 通过腾讯服务器和相隔万里的朋友吃鸡

解脱了对象之间多对多的引用依赖，所有对象之间的通信，都封装在中介者（`Mediator`）里面

*winform 开发,各个控件都在Form类中协作。*

### 23.解释器模式

**这个模式比较复杂**，常见于手动构建表达式树，[后缀表达式](https://www.jianshu.com/p/f2c88d983ff5)（逆波兰式）设计中，推荐直接用在静态语言中嵌入脚本引擎解决此类问题，C#,JAVA均可支持嵌入JS，python等脚本语言。

[解释器模式讲解](http://blog.csdn.net/yanbober/article/details/45537601)


