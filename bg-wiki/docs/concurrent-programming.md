## 并发编程

### 概念

术语|解释
-|-
并发|强调某一时段，有多件事发生，比如一边敲代码一边看电视（交替执行，眼睛某一时刻只能选择一个）
并行|相对于串行，某一时刻能同时执行多个任务，如双核四线程（超线程技术）CPU能同时执行四个程序流

### 操作系统的并发能力及实现方式

操作系统是管理硬件资源的，为提高资源利用率，操作系统设计为多道分时程序系统，一般来说提供最基础的两个执行单元，`进程`及`线程`

术语|解释
-|-
地址空间|现代操作系统都有内存虚拟化技术，段页式内存管理，在必要时可通过`虚拟内存`(在辅存上)扩展主存空间，每个进程都会划分一块地盘（虚拟地址空间），操作系统管理虚拟内存与物理内存的映射及换入换出
进程|进行资源分配和调度的基本单位，目的是隔离程序，每进程拥有独立的地址空间
线程|最小执行单元，目的是隔离程序内的子程序，进程内多个线程共享同一个地址空间

操作系统为了调度和审计进程与线程，需要管理其元数据，进程对应`进程描述符PD`，线程对应`线程描述符TD`,都是需要耗内存的，在应用程序看来，属于重量级

### 并发编程的基本思路

术语|解释
-|-
基于状态共享|多线程的方式，共享某些变量，需要做好线程同步，否则容易死锁，这种方式由于是直接借助操作系统，因此可以看作是裸奔，翻车系数高
基于消息传递|在操作系统之上抽象了一层逻辑最小执行单元（轻量级），比如“erlang进程”、“协程”、“goroutine”,彼此通过消息来通信，不允许共享变量

并发编程的挑战？
	传统多线程编程，线程之间共享变量是bug的源头


### 程序的并发能力及实现方式

谈到并发编程，鼻祖级当属[**Erlang**](https://baike.baidu.com/item/Erlang/1152752?fr=aladdin)，erlang是爱立信在80年代末为电信系统设计的，该语言在国内流行于**广州**(页游之都)
erlang是函数式编程语言（和数学一样，x=3为表达式，没有变量和赋值的概念，即x之后不能像其它语言一样那样x=4）

erlang不满足于操作系统提供的进程与线程两种基本能力，设计出独特的 `erlang进程`，`erlang进程`是独立的子程序，且只能通过收发消息进行协同。由于`erlang进程`比较轻量级，因此可以创建非常多的数量来充分利用物理机器。

大名鼎鼎的`RabbitMQ`,及用Erlang重写的`CouchDB`是erlang的经典之作

** erlang后来的模仿者 **

术语|解释
-|-
[go](https://golang.org/)|【Google】抽象出goroutine，在goroutine之间用chan（通道）传递消息
[scala](https://www.scala-lang.org/)|构建在jvm之上，也有类似erlang的收发消息的原语操作
[rust](https://www.rust-lang.org/zh-CN/)|【Mozilla】特色：lifetime,Ownership,channel

### Actor 模型

现实生活就是一个actor模型的例子，上级给下属分配任务，只要传达其一个消息即可，任务由下属完成，完后之后汇报给上级。上级可以管理多个下属（树结构）。
在此案例中，下属是独立的任务执行者（Actor），上级与下属之间用消息通信。

*ps:复杂问题的解决方案往往就在你我生活之中*

### 响应式编程(Reactive)

即异步编程模型，即一切操作都是异步的，在完成之后回调继续下一步，ajax再调ajax就属于这种情况

术语|解释
-|-
[nodejs](https://nodejs.org/en/)|【单线程+多进程集群】因为JS天生异步（JS没有阻塞函数，除了浏览器的alert弹出会阻塞），编码风格就是回调风格
[vert.x](https://vertx.io/)|【消息传递】抛弃了传统的servlet，使用netty（nio）重建整个http管线
[akka](https://akka.io/)|【消息传递】scala编写的一个面向并发编程的运行时
Rx*|[RxJS](https://cn.rx.js.org/)，[RxJava](https://github.com/ReactiveX/RxJava),...
[Spring5](https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1)|Spring Reactive

